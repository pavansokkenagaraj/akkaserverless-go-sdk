// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package eventing

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	anypb "google.golang.org/protobuf/types/known/anypb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LocalPersistenceSubscriberModelClient is the client API for LocalPersistenceSubscriberModel service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LocalPersistenceSubscriberModelClient interface {
	ProcessEventOne(ctx context.Context, in *EventOne, opts ...grpc.CallOption) (*Response, error)
	ProcessEventTwo(ctx context.Context, in *EventTwo, opts ...grpc.CallOption) (LocalPersistenceSubscriberModel_ProcessEventTwoClient, error)
	ProcessAnyEvent(ctx context.Context, in *anypb.Any, opts ...grpc.CallOption) (*Response, error)
	ProcessValueOne(ctx context.Context, in *ValueOne, opts ...grpc.CallOption) (*Response, error)
	ProcessValueTwo(ctx context.Context, in *ValueTwo, opts ...grpc.CallOption) (LocalPersistenceSubscriberModel_ProcessValueTwoClient, error)
	ProcessAnyValue(ctx context.Context, in *anypb.Any, opts ...grpc.CallOption) (*Response, error)
	Effect(ctx context.Context, in *EffectRequest, opts ...grpc.CallOption) (*Response, error)
}

type localPersistenceSubscriberModelClient struct {
	cc grpc.ClientConnInterface
}

func NewLocalPersistenceSubscriberModelClient(cc grpc.ClientConnInterface) LocalPersistenceSubscriberModelClient {
	return &localPersistenceSubscriberModelClient{cc}
}

func (c *localPersistenceSubscriberModelClient) ProcessEventOne(ctx context.Context, in *EventOne, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/akkaserverless.tck.model.eventing.LocalPersistenceSubscriberModel/ProcessEventOne", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localPersistenceSubscriberModelClient) ProcessEventTwo(ctx context.Context, in *EventTwo, opts ...grpc.CallOption) (LocalPersistenceSubscriberModel_ProcessEventTwoClient, error) {
	stream, err := c.cc.NewStream(ctx, &LocalPersistenceSubscriberModel_ServiceDesc.Streams[0], "/akkaserverless.tck.model.eventing.LocalPersistenceSubscriberModel/ProcessEventTwo", opts...)
	if err != nil {
		return nil, err
	}
	x := &localPersistenceSubscriberModelProcessEventTwoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LocalPersistenceSubscriberModel_ProcessEventTwoClient interface {
	Recv() (*Response, error)
	grpc.ClientStream
}

type localPersistenceSubscriberModelProcessEventTwoClient struct {
	grpc.ClientStream
}

func (x *localPersistenceSubscriberModelProcessEventTwoClient) Recv() (*Response, error) {
	m := new(Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *localPersistenceSubscriberModelClient) ProcessAnyEvent(ctx context.Context, in *anypb.Any, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/akkaserverless.tck.model.eventing.LocalPersistenceSubscriberModel/ProcessAnyEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localPersistenceSubscriberModelClient) ProcessValueOne(ctx context.Context, in *ValueOne, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/akkaserverless.tck.model.eventing.LocalPersistenceSubscriberModel/ProcessValueOne", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localPersistenceSubscriberModelClient) ProcessValueTwo(ctx context.Context, in *ValueTwo, opts ...grpc.CallOption) (LocalPersistenceSubscriberModel_ProcessValueTwoClient, error) {
	stream, err := c.cc.NewStream(ctx, &LocalPersistenceSubscriberModel_ServiceDesc.Streams[1], "/akkaserverless.tck.model.eventing.LocalPersistenceSubscriberModel/ProcessValueTwo", opts...)
	if err != nil {
		return nil, err
	}
	x := &localPersistenceSubscriberModelProcessValueTwoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LocalPersistenceSubscriberModel_ProcessValueTwoClient interface {
	Recv() (*Response, error)
	grpc.ClientStream
}

type localPersistenceSubscriberModelProcessValueTwoClient struct {
	grpc.ClientStream
}

func (x *localPersistenceSubscriberModelProcessValueTwoClient) Recv() (*Response, error) {
	m := new(Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *localPersistenceSubscriberModelClient) ProcessAnyValue(ctx context.Context, in *anypb.Any, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/akkaserverless.tck.model.eventing.LocalPersistenceSubscriberModel/ProcessAnyValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localPersistenceSubscriberModelClient) Effect(ctx context.Context, in *EffectRequest, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/akkaserverless.tck.model.eventing.LocalPersistenceSubscriberModel/Effect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LocalPersistenceSubscriberModelServer is the server API for LocalPersistenceSubscriberModel service.
// All implementations must embed UnimplementedLocalPersistenceSubscriberModelServer
// for forward compatibility
type LocalPersistenceSubscriberModelServer interface {
	ProcessEventOne(context.Context, *EventOne) (*Response, error)
	ProcessEventTwo(*EventTwo, LocalPersistenceSubscriberModel_ProcessEventTwoServer) error
	ProcessAnyEvent(context.Context, *anypb.Any) (*Response, error)
	ProcessValueOne(context.Context, *ValueOne) (*Response, error)
	ProcessValueTwo(*ValueTwo, LocalPersistenceSubscriberModel_ProcessValueTwoServer) error
	ProcessAnyValue(context.Context, *anypb.Any) (*Response, error)
	Effect(context.Context, *EffectRequest) (*Response, error)
	mustEmbedUnimplementedLocalPersistenceSubscriberModelServer()
}

// UnimplementedLocalPersistenceSubscriberModelServer must be embedded to have forward compatible implementations.
type UnimplementedLocalPersistenceSubscriberModelServer struct {
}

func (UnimplementedLocalPersistenceSubscriberModelServer) ProcessEventOne(context.Context, *EventOne) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessEventOne not implemented")
}
func (UnimplementedLocalPersistenceSubscriberModelServer) ProcessEventTwo(*EventTwo, LocalPersistenceSubscriberModel_ProcessEventTwoServer) error {
	return status.Errorf(codes.Unimplemented, "method ProcessEventTwo not implemented")
}
func (UnimplementedLocalPersistenceSubscriberModelServer) ProcessAnyEvent(context.Context, *anypb.Any) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessAnyEvent not implemented")
}
func (UnimplementedLocalPersistenceSubscriberModelServer) ProcessValueOne(context.Context, *ValueOne) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessValueOne not implemented")
}
func (UnimplementedLocalPersistenceSubscriberModelServer) ProcessValueTwo(*ValueTwo, LocalPersistenceSubscriberModel_ProcessValueTwoServer) error {
	return status.Errorf(codes.Unimplemented, "method ProcessValueTwo not implemented")
}
func (UnimplementedLocalPersistenceSubscriberModelServer) ProcessAnyValue(context.Context, *anypb.Any) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessAnyValue not implemented")
}
func (UnimplementedLocalPersistenceSubscriberModelServer) Effect(context.Context, *EffectRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Effect not implemented")
}
func (UnimplementedLocalPersistenceSubscriberModelServer) mustEmbedUnimplementedLocalPersistenceSubscriberModelServer() {
}

// UnsafeLocalPersistenceSubscriberModelServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LocalPersistenceSubscriberModelServer will
// result in compilation errors.
type UnsafeLocalPersistenceSubscriberModelServer interface {
	mustEmbedUnimplementedLocalPersistenceSubscriberModelServer()
}

func RegisterLocalPersistenceSubscriberModelServer(s grpc.ServiceRegistrar, srv LocalPersistenceSubscriberModelServer) {
	s.RegisterService(&LocalPersistenceSubscriberModel_ServiceDesc, srv)
}

func _LocalPersistenceSubscriberModel_ProcessEventOne_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventOne)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalPersistenceSubscriberModelServer).ProcessEventOne(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/akkaserverless.tck.model.eventing.LocalPersistenceSubscriberModel/ProcessEventOne",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalPersistenceSubscriberModelServer).ProcessEventOne(ctx, req.(*EventOne))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalPersistenceSubscriberModel_ProcessEventTwo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EventTwo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LocalPersistenceSubscriberModelServer).ProcessEventTwo(m, &localPersistenceSubscriberModelProcessEventTwoServer{stream})
}

type LocalPersistenceSubscriberModel_ProcessEventTwoServer interface {
	Send(*Response) error
	grpc.ServerStream
}

type localPersistenceSubscriberModelProcessEventTwoServer struct {
	grpc.ServerStream
}

func (x *localPersistenceSubscriberModelProcessEventTwoServer) Send(m *Response) error {
	return x.ServerStream.SendMsg(m)
}

func _LocalPersistenceSubscriberModel_ProcessAnyEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(anypb.Any)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalPersistenceSubscriberModelServer).ProcessAnyEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/akkaserverless.tck.model.eventing.LocalPersistenceSubscriberModel/ProcessAnyEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalPersistenceSubscriberModelServer).ProcessAnyEvent(ctx, req.(*anypb.Any))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalPersistenceSubscriberModel_ProcessValueOne_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValueOne)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalPersistenceSubscriberModelServer).ProcessValueOne(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/akkaserverless.tck.model.eventing.LocalPersistenceSubscriberModel/ProcessValueOne",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalPersistenceSubscriberModelServer).ProcessValueOne(ctx, req.(*ValueOne))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalPersistenceSubscriberModel_ProcessValueTwo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ValueTwo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LocalPersistenceSubscriberModelServer).ProcessValueTwo(m, &localPersistenceSubscriberModelProcessValueTwoServer{stream})
}

type LocalPersistenceSubscriberModel_ProcessValueTwoServer interface {
	Send(*Response) error
	grpc.ServerStream
}

type localPersistenceSubscriberModelProcessValueTwoServer struct {
	grpc.ServerStream
}

func (x *localPersistenceSubscriberModelProcessValueTwoServer) Send(m *Response) error {
	return x.ServerStream.SendMsg(m)
}

func _LocalPersistenceSubscriberModel_ProcessAnyValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(anypb.Any)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalPersistenceSubscriberModelServer).ProcessAnyValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/akkaserverless.tck.model.eventing.LocalPersistenceSubscriberModel/ProcessAnyValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalPersistenceSubscriberModelServer).ProcessAnyValue(ctx, req.(*anypb.Any))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalPersistenceSubscriberModel_Effect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EffectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalPersistenceSubscriberModelServer).Effect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/akkaserverless.tck.model.eventing.LocalPersistenceSubscriberModel/Effect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalPersistenceSubscriberModelServer).Effect(ctx, req.(*EffectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LocalPersistenceSubscriberModel_ServiceDesc is the grpc.ServiceDesc for LocalPersistenceSubscriberModel service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LocalPersistenceSubscriberModel_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "akkaserverless.tck.model.eventing.LocalPersistenceSubscriberModel",
	HandlerType: (*LocalPersistenceSubscriberModelServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProcessEventOne",
			Handler:    _LocalPersistenceSubscriberModel_ProcessEventOne_Handler,
		},
		{
			MethodName: "ProcessAnyEvent",
			Handler:    _LocalPersistenceSubscriberModel_ProcessAnyEvent_Handler,
		},
		{
			MethodName: "ProcessValueOne",
			Handler:    _LocalPersistenceSubscriberModel_ProcessValueOne_Handler,
		},
		{
			MethodName: "ProcessAnyValue",
			Handler:    _LocalPersistenceSubscriberModel_ProcessAnyValue_Handler,
		},
		{
			MethodName: "Effect",
			Handler:    _LocalPersistenceSubscriberModel_Effect_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ProcessEventTwo",
			Handler:       _LocalPersistenceSubscriberModel_ProcessEventTwo_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ProcessValueTwo",
			Handler:       _LocalPersistenceSubscriberModel_ProcessValueTwo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "eventing/local_persistence_eventing.proto",
}

// EventSourcedEntityOneClient is the client API for EventSourcedEntityOne service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EventSourcedEntityOneClient interface {
	EmitEvent(ctx context.Context, in *EmitEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type eventSourcedEntityOneClient struct {
	cc grpc.ClientConnInterface
}

func NewEventSourcedEntityOneClient(cc grpc.ClientConnInterface) EventSourcedEntityOneClient {
	return &eventSourcedEntityOneClient{cc}
}

func (c *eventSourcedEntityOneClient) EmitEvent(ctx context.Context, in *EmitEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/akkaserverless.tck.model.eventing.EventSourcedEntityOne/EmitEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventSourcedEntityOneServer is the server API for EventSourcedEntityOne service.
// All implementations must embed UnimplementedEventSourcedEntityOneServer
// for forward compatibility
type EventSourcedEntityOneServer interface {
	EmitEvent(context.Context, *EmitEventRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedEventSourcedEntityOneServer()
}

// UnimplementedEventSourcedEntityOneServer must be embedded to have forward compatible implementations.
type UnimplementedEventSourcedEntityOneServer struct {
}

func (UnimplementedEventSourcedEntityOneServer) EmitEvent(context.Context, *EmitEventRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmitEvent not implemented")
}
func (UnimplementedEventSourcedEntityOneServer) mustEmbedUnimplementedEventSourcedEntityOneServer() {}

// UnsafeEventSourcedEntityOneServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventSourcedEntityOneServer will
// result in compilation errors.
type UnsafeEventSourcedEntityOneServer interface {
	mustEmbedUnimplementedEventSourcedEntityOneServer()
}

func RegisterEventSourcedEntityOneServer(s grpc.ServiceRegistrar, srv EventSourcedEntityOneServer) {
	s.RegisterService(&EventSourcedEntityOne_ServiceDesc, srv)
}

func _EventSourcedEntityOne_EmitEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmitEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventSourcedEntityOneServer).EmitEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/akkaserverless.tck.model.eventing.EventSourcedEntityOne/EmitEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventSourcedEntityOneServer).EmitEvent(ctx, req.(*EmitEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EventSourcedEntityOne_ServiceDesc is the grpc.ServiceDesc for EventSourcedEntityOne service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventSourcedEntityOne_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "akkaserverless.tck.model.eventing.EventSourcedEntityOne",
	HandlerType: (*EventSourcedEntityOneServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EmitEvent",
			Handler:    _EventSourcedEntityOne_EmitEvent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eventing/local_persistence_eventing.proto",
}

// EventSourcedEntityTwoClient is the client API for EventSourcedEntityTwo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EventSourcedEntityTwoClient interface {
	EmitJsonEvent(ctx context.Context, in *JsonEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type eventSourcedEntityTwoClient struct {
	cc grpc.ClientConnInterface
}

func NewEventSourcedEntityTwoClient(cc grpc.ClientConnInterface) EventSourcedEntityTwoClient {
	return &eventSourcedEntityTwoClient{cc}
}

func (c *eventSourcedEntityTwoClient) EmitJsonEvent(ctx context.Context, in *JsonEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/akkaserverless.tck.model.eventing.EventSourcedEntityTwo/EmitJsonEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventSourcedEntityTwoServer is the server API for EventSourcedEntityTwo service.
// All implementations must embed UnimplementedEventSourcedEntityTwoServer
// for forward compatibility
type EventSourcedEntityTwoServer interface {
	EmitJsonEvent(context.Context, *JsonEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedEventSourcedEntityTwoServer()
}

// UnimplementedEventSourcedEntityTwoServer must be embedded to have forward compatible implementations.
type UnimplementedEventSourcedEntityTwoServer struct {
}

func (UnimplementedEventSourcedEntityTwoServer) EmitJsonEvent(context.Context, *JsonEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmitJsonEvent not implemented")
}
func (UnimplementedEventSourcedEntityTwoServer) mustEmbedUnimplementedEventSourcedEntityTwoServer() {}

// UnsafeEventSourcedEntityTwoServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventSourcedEntityTwoServer will
// result in compilation errors.
type UnsafeEventSourcedEntityTwoServer interface {
	mustEmbedUnimplementedEventSourcedEntityTwoServer()
}

func RegisterEventSourcedEntityTwoServer(s grpc.ServiceRegistrar, srv EventSourcedEntityTwoServer) {
	s.RegisterService(&EventSourcedEntityTwo_ServiceDesc, srv)
}

func _EventSourcedEntityTwo_EmitJsonEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JsonEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventSourcedEntityTwoServer).EmitJsonEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/akkaserverless.tck.model.eventing.EventSourcedEntityTwo/EmitJsonEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventSourcedEntityTwoServer).EmitJsonEvent(ctx, req.(*JsonEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// EventSourcedEntityTwo_ServiceDesc is the grpc.ServiceDesc for EventSourcedEntityTwo service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventSourcedEntityTwo_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "akkaserverless.tck.model.eventing.EventSourcedEntityTwo",
	HandlerType: (*EventSourcedEntityTwoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EmitJsonEvent",
			Handler:    _EventSourcedEntityTwo_EmitJsonEvent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eventing/local_persistence_eventing.proto",
}

// ValueEntityOneClient is the client API for ValueEntityOne service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ValueEntityOneClient interface {
	UpdateValue(ctx context.Context, in *UpdateValueRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type valueEntityOneClient struct {
	cc grpc.ClientConnInterface
}

func NewValueEntityOneClient(cc grpc.ClientConnInterface) ValueEntityOneClient {
	return &valueEntityOneClient{cc}
}

func (c *valueEntityOneClient) UpdateValue(ctx context.Context, in *UpdateValueRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/akkaserverless.tck.model.eventing.ValueEntityOne/UpdateValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ValueEntityOneServer is the server API for ValueEntityOne service.
// All implementations must embed UnimplementedValueEntityOneServer
// for forward compatibility
type ValueEntityOneServer interface {
	UpdateValue(context.Context, *UpdateValueRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedValueEntityOneServer()
}

// UnimplementedValueEntityOneServer must be embedded to have forward compatible implementations.
type UnimplementedValueEntityOneServer struct {
}

func (UnimplementedValueEntityOneServer) UpdateValue(context.Context, *UpdateValueRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateValue not implemented")
}
func (UnimplementedValueEntityOneServer) mustEmbedUnimplementedValueEntityOneServer() {}

// UnsafeValueEntityOneServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ValueEntityOneServer will
// result in compilation errors.
type UnsafeValueEntityOneServer interface {
	mustEmbedUnimplementedValueEntityOneServer()
}

func RegisterValueEntityOneServer(s grpc.ServiceRegistrar, srv ValueEntityOneServer) {
	s.RegisterService(&ValueEntityOne_ServiceDesc, srv)
}

func _ValueEntityOne_UpdateValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValueEntityOneServer).UpdateValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/akkaserverless.tck.model.eventing.ValueEntityOne/UpdateValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValueEntityOneServer).UpdateValue(ctx, req.(*UpdateValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ValueEntityOne_ServiceDesc is the grpc.ServiceDesc for ValueEntityOne service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ValueEntityOne_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "akkaserverless.tck.model.eventing.ValueEntityOne",
	HandlerType: (*ValueEntityOneServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateValue",
			Handler:    _ValueEntityOne_UpdateValue_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eventing/local_persistence_eventing.proto",
}

// ValueEntityTwoClient is the client API for ValueEntityTwo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ValueEntityTwoClient interface {
	UpdateJsonValue(ctx context.Context, in *JsonValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type valueEntityTwoClient struct {
	cc grpc.ClientConnInterface
}

func NewValueEntityTwoClient(cc grpc.ClientConnInterface) ValueEntityTwoClient {
	return &valueEntityTwoClient{cc}
}

func (c *valueEntityTwoClient) UpdateJsonValue(ctx context.Context, in *JsonValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/akkaserverless.tck.model.eventing.ValueEntityTwo/UpdateJsonValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ValueEntityTwoServer is the server API for ValueEntityTwo service.
// All implementations must embed UnimplementedValueEntityTwoServer
// for forward compatibility
type ValueEntityTwoServer interface {
	UpdateJsonValue(context.Context, *JsonValue) (*emptypb.Empty, error)
	mustEmbedUnimplementedValueEntityTwoServer()
}

// UnimplementedValueEntityTwoServer must be embedded to have forward compatible implementations.
type UnimplementedValueEntityTwoServer struct {
}

func (UnimplementedValueEntityTwoServer) UpdateJsonValue(context.Context, *JsonValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateJsonValue not implemented")
}
func (UnimplementedValueEntityTwoServer) mustEmbedUnimplementedValueEntityTwoServer() {}

// UnsafeValueEntityTwoServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ValueEntityTwoServer will
// result in compilation errors.
type UnsafeValueEntityTwoServer interface {
	mustEmbedUnimplementedValueEntityTwoServer()
}

func RegisterValueEntityTwoServer(s grpc.ServiceRegistrar, srv ValueEntityTwoServer) {
	s.RegisterService(&ValueEntityTwo_ServiceDesc, srv)
}

func _ValueEntityTwo_UpdateJsonValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JsonValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValueEntityTwoServer).UpdateJsonValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/akkaserverless.tck.model.eventing.ValueEntityTwo/UpdateJsonValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValueEntityTwoServer).UpdateJsonValue(ctx, req.(*JsonValue))
	}
	return interceptor(ctx, in, info, handler)
}

// ValueEntityTwo_ServiceDesc is the grpc.ServiceDesc for ValueEntityTwo service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ValueEntityTwo_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "akkaserverless.tck.model.eventing.ValueEntityTwo",
	HandlerType: (*ValueEntityTwoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateJsonValue",
			Handler:    _ValueEntityTwo_UpdateJsonValue_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eventing/local_persistence_eventing.proto",
}
